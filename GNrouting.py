# PERFORMANCE ESTIMATOR
# Author: Josh Nevin 
# Calculation of SNR, BER, MI for AWGN channel using GN model 
# REFS: The GN Model of Non-Linear Propagation in Uncompensated Coherent Optical Systems - Pierluigi Poggiolini
# Information Rate in Ultra-Wideband Optical Fiber Communication Systems Accounting for High-Order Dispersion - Nikita A. Shevchenko et. al.
# Data from NDFIS: NDFIS_cheatsheet_ives.docx
# UCL OTN course notes 
# On the Bit Error Probability of QAM ModulationMichael - P. Fitz and James P. Seymour

# %% ################### imports ####################
import numpy as np
import matplotlib.pyplot as plt
import multiprocessing
import time 
from scipy import special
#from scipy.stats import iqr
#from sklearn.gaussian_process import GaussianProcessRegressor
#from sklearn.gaussian_process.kernels import RBF
from GHquad import GHquad
from NFmodelGNPy import nf_model
from NFmodelGNPy import lin2db
from NFmodelGNPy import db2lin
from GNf import GNmain
import random
from dijkstra import dijkstra
import matplotlib

datagen = False
repairlossimport = False
constellationimport = True
reachcalculation = False
histogramstuff = False
MIstuff = False
#addnoise = True

numpoints = 100

# %% ================================ NDFIS data stuff  ===========================================
if reachcalculation:
    NDFISdata = np.genfromtxt(open("NDFISdata.csv", "r"), delimiter=",", dtype =float)
    NDFISdata = np.delete(NDFISdata,0,0 )
    # extract loss and overall loss and remove links for which loss or overall loss is missing 
    NDFISdatanozero = np.delete(NDFISdata,[16,17,20,21],0 )  
    NDFISlossnz = NDFISdatanozero.T[2]
    NDFISlossoverallnz = NDFISdatanozero.T[4]
    NDFISdispnz = NDFISdatanozero.T[6]
    # calculate mean and variance 
    NDFISlossnzmean = np.mean(NDFISlossnz)
    NDFISlossoverallnzmean = np.mean(NDFISlossoverallnz)
    NDFISdispnzmean = np.mean(NDFISdispnz)
    NDFISlossnzvar = np.var(NDFISlossnz)
    NDFISlossoverallnzvar = np.var(NDFISlossoverallnz)
    NDFISdispnzvar = np.var(NDFISdispnz)
    # work out standard deviation = sqrt(variance) as a % of the mean 
    lossvarperc = ((NDFISlossnzvar**0.5)/NDFISlossnzmean)*100  
    lossvarpercoverall = ((NDFISlossoverallnzvar**0.5)/NDFISlossoverallnzmean)*100  
    dispvarperc = ((NDFISdispnzvar**0.5)/NDFISdispnzmean)*100 
    
if repairlossimport:
    # import repair loss data generated by David's implementation of J. A. Nagel,
    #“Statistical Analysis of Single-Mode Fiber Field Splice Losses,” in OFC 2009, p. JWA3.'
    repairlossdata = np.genfromtxt(open("Astotal.csv", "r"), delimiter=",", dtype =float)
    nbinsrep = int(np.genfromtxt(open("Astotalnbins.csv", "r"), delimiter=",", dtype =float))
    countsrep, binsrep = np.histogram(repairlossdata, nbinsrep)

# %% ======================== NDFIS loss fitting stuff ======================== 
if histogramstuff: 
    # find bin width from Friedman-Diaconis rule 
    # =============================================================================
    # Binwid = (2*iqr(NDFISlossnz))/(np.size(NDFISlossnz)**(1/3))
    # Binnum = (np.max(NDFISlossnz) - np.min(NDFISlossnz))/Binwid
    # Binnum = int(np.around(Binnum, decimals=0))
    # Binwido = (2*iqr(NDFISlossoverallnz))/(np.size(NDFISlossoverallnz)**(1/3))
    # Binnumo = (np.max(NDFISlossoverallnz) - np.min(NDFISlossoverallnz))/Binwido
    # Binnumo = int(np.around(Binnumo, decimals=0))
    # =============================================================================
    # calculate bins for histogram stuff 
    #counts, bins = np.histogram(NDFISlossnz, Binnum)
    #countso, binso = np.histogram(NDFISlossoverallnz, Binnumo)
    counts, bins = np.histogram(NDFISlossnz, 20)
    countso, binso = np.histogram(NDFISlossoverallnz, 20)
    countsd, binsd = np.histogram(NDFISdispnz, 20)
    
    # how to reconstruct histogram 
    # =============================================================================
    # xloss = [bins[i]*np.ones(np.size(counts))  for i in range(np.size(bins))   ]
    # xloss = np.reshape(xloss, np.size(xloss))
    # 
    # yloss = [counts[i]*np.ones(np.size(bins))  for i in range(np.size(counts))   ]
    # yloss = np.reshape(yloss, np.size(yloss))
    # 
    # plt.plot(xloss,yloss)
    # plt.xlabel("loss (dB/km)")
    # plt.ylabel("freqeuncy")
    # plt.savefig('NDFISlosshist.png', dpi=200)
    # plt.show()
    # =============================================================================
    # %% random draws from histogram 
    
    countsnorm = np.zeros(np.size(counts))
    for i in range(np.size(countsnorm)):
        countsnorm[i] = counts[i]/np.sum(counts)
    countsnormo = np.zeros(np.size(countso))
    for i in range(np.size(countsnormo)):
        countsnormo[i] = countso[i]/np.sum(countso)
    countsnormd = np.zeros(np.size(countsd))
    for i in range(np.size(countsnormd)):
        countsnormd[i] = countsd[i]/np.sum(countsd)
    countsnormrep = np.zeros(np.size(countsrep))
    for i in range(np.size(countsnormrep)):
        countsnormrep[i] = countsrep[i]/np.sum(countsrep)
    def histdraw(counts, bins):
        np.random.seed()
        randnum = np.random.uniform(0,1)
        #print("random draw " + str(randnum))
        for i in range(np.size(counts)):
            if randnum < np.sum(np.split(counts, [i+1])[0]):
                #print("checksum " + str(np.sum(np.split(countsnorm, [i+1])[0])))
                drawnum = np.random.uniform(bins[i],bins[i+1])
                break
        return drawnum
# %%  ================================ set params and call main ================================
#dev = 1  # % deviation from baseline 
PchdBm = np.linspace(-10, 10, num = numpoints, dtype =float) 
#PchdBm = 0
#alpha = 0.25
Nspans = 3
LspansN = 100
LspansD = 80
num_breaks = 0 # set the number of fibre breaks
num_years = (num_breaks*374)/(Nspans*LspansN) # expected number of years for this number of fibre breaks given a rate of 1 break/374km/year
#alpha = NDFISlossnzmean
alpha = 0.2
#alpha = np.zeros(numpoints)
#for i in range(numpoints):
#    alpha[i] = histdraw(countsnorm, bins)
#alpha = NDFISlossnzmean
#Disp = np.random.normal(NDFISdispnzmean, NDFISdispnzvar**0.5, numpoints)
NLco = 1.27
NchRS = 101
#Disp = NDFISdispnzmean
Disp = 16.7
gain_target = alpha*LspansN
# =============================================================================
# gain_max = 26  # operator model example from GNPy - see eqpt_config.json 
# gain_min = 15
# nf_min = 6
# nf_max = 10 
# nf1 = nf_model(gain_min,gain_max,nf_min,nf_max )[0]
# nf2 = nf_model(gain_min,gain_max,nf_min,nf_max )[1]
# deltap = nf_model(gain_min,gain_max,nf_min,nf_max )[2]
# g1max = nf_model(gain_min,gain_max,nf_min,nf_max )[3]
# g1min = nf_model(gain_min,gain_max,nf_min,nf_max )[4]
# g1a = gain_target - deltap - (gain_max - gain_target)
# NF = lin2db(db2lin(nf1) + db2lin(nf2)/db2lin(g1a))  
# =============================================================================
NF = 5.5
# %% SNR variation due to ripple emulation

ripplepertmax = 0.1
ripplepertmin = -0.1
ripplepertmaxpowerdep = 0.4
ripplepertminpowerdep = -1.0

def rippledatagen(PchdBm,numspans):
    Gnli = np.empty([numspans,numpoints])
    ep = np.empty([numspans,1])
    lam = 1550
    Rs = 32
    f = 299792458/(lam*1e-9) # operating frequency [Hz]
    h = 6.63*1e-34  # Planck's constant [Js] 
    Pun = GNmain(LspansN, 1, 157, 101, 201, alpha, Disp, PchdBm, NF, NLco,False,numpoints)[0]
    Popt = PchdBm[np.argmax(Pun)] 
    Poptr = np.linspace(Popt-1.5, Popt+1.5, numpoints)
    Poptran = Poptr  +  np.random.uniform(ripplepertmin, ripplepertmax, numpoints)
    #Poptran = Poptr  +  (10**(np.random.uniform(ripplepertmaxpowerdep, ripplepertminpowerdep, numpoints)/10) - 1)*Poptr
    #Poptran = lin2db(db2lin(Poptr)+(10**(np.random.uniform(ripplepertmaxpowerdep, ripplepertminpowerdep, numpoints)/10) - 1)*db2lin(Poptr))
    for i in range(numspans):
        Gnli[i] = GNmain(LspansN, 1, 157, 101, 201, alpha, Disp, Poptran, NF, NLco,False,numpoints)[4]
        Poptran = Poptran  +  np.random.uniform(ripplepertmin, ripplepertmax, numpoints)
        #Poptran = Poptr  +  (10**(np.random.uniform(ripplepertmaxpowerdep, ripplepertminpowerdep, numpoints)/10) - 1)*Poptr
        #Poptran = lin2db(db2lin(Poptr)  + (10**(np.random.uniform(ripplepertmaxpowerdep, ripplepertminpowerdep, numpoints)/10) - 1)*db2lin(Poptr))
    ep = GNmain(LspansN, numspans, 157, 101, 201, alpha, Disp, Poptran, NF, NLco,False,numpoints)[5]    
    Pase = NF*h*f*(db2lin(gain_target) - 1)*Rs*1e9*numspans
    Gnli = np.sum(Gnli,axis=0)*(Nspans**ep)
    #Pch = 1e-3*db2lin(PchdBm/10)  # ^ [W]
    Pch = 1e-3*10**(Poptran/10)  # ^ [W]
    return lin2db((Pch)/(Pase + Gnli*Rs*1e9)), Popt
    
#SNRripple, Popt = rippledatagen(PchdBm,10)
#Pchripple = np.linspace(Popt-1.5, Popt+1.5, numpoints)


#Poptr = np.linspace(Popt-1.5, Popt+1.5, numpoints)
#test  = (10**(np.random.uniform(ripplepertmaxpowerdep, ripplepertminpowerdep, numpoints)/10) - 1)
#test2  = (10**(-0.4/10) - 1)
#plt.plot(Pchripple, SNRripple,'+')
#plt.title('Power excursion data')
#plt.xlabel("Pch(dBm)")
#plt.ylabel("SNR(dB)")
#plt.savefig('Apowerexcursion.png', dpi=200)
#plt.show()
#np.savetxt('Pchripple10.csv', Pchripple, delimiter=',') 
#np.savetxt('SNRripple10.csv', SNRripple, delimiter=',') 
#np.savetxt('Pchnum75.csv', Pchripple, delimiter=',') 
#np.savetxt('SNRnum75.csv', SNRripple, delimiter=',') 
# %% graph definitions
nodesN = ['1','2','3','4','5','6','7','8','9','10','11','12','13','14']

graphN = {'1':{'2':2100,'3':3000,'8':4800},'2':{'1':2100,'3':1200,'4':1500},'3':{'1':3000,'2':1200,'6':3600},    
         '4':{'2':1500,'5':1200,'11':3900},'5':{'4':1200,'6':2400,'7':1200}, '6':{'3':3600,'5':2400,'10':2100,'14':3600},
         '7':{'5':1200,'8':1500,'10':2700}, '8':{'1':4800,'7':1500,'9':1500}, '9':{'8':1500,'10':1500,'12':600,'13':600},
         '10':{'6':2100,'7':2700,'9':1500}, '11':{'4':3900,'12':1200,'13':1500}, '12':{'9':600,'11':1200,'14':600},
         '13':{'9':600,'11':1500,'14':300}, '14':{'6':3600,'12':600,'13':300}
         } 
graphnormN = {'1':{'2':2100,'3':3000,'8':4800},'2':{'1':2100,'3':1200,'4':1500},'3':{'1':3000,'2':1200,'6':3600},    
         '4':{'2':1500,'5':1200,'11':3900},'5':{'4':1200,'6':2400,'7':1200}, '6':{'3':3600,'5':2400,'10':2100,'14':3600},
         '7':{'5':1200,'8':1500,'10':2700}, '8':{'1':4800,'7':1500,'9':1500}, '9':{'8':1500,'10':1500,'12':600,'13':600},
         '10':{'6':2100,'7':2700,'9':1500}, '11':{'4':3900,'12':1200,'13':1500}, '12':{'9':600,'11':1200,'14':600},
         '13':{'9':600,'11':1500,'14':300}, '14':{'6':3600,'12':600,'13':300}
         }        
edgesN = {'1':{'2':0,'3':1,'8':2},'2':{'1':3,'3':4,'4':5},'3':{'1':6,'2':7,'6':8},    
         '4':{'2':9,'5':10,'11':11},'5':{'4':12,'6':13,'7':14}, '6':{'3':15,'5':16,'10':17,'14':18},
         '7':{'5':19,'8':20,'10':21}, '8':{'1':22,'7':23,'9':24}, '9':{'8':25,'10':26,'12':27,'13':28},
         '10':{'6':29,'7':30,'9':31}, '11':{'4':32,'12':33,'13':34}, '12':{'9':35,'11':36,'14':37},
         '13':{'9':38,'11':39,'14':40}, '14':{'6':41,'12':42,'13':43}
         }
numedgesN = 44
LspansN = 100

nodesD = ['1','2','3','4','5','6','7','8','9','10','11','12','13','14']

graphD = {'1':{'2':400,'3':160,'4':160},'2':{'1':400,'4':400,'5':240},'3':{'1':160,'4':160,'6':320},    
         '4':{'1':160,'2':400,'3':160,'5':320,'7':240,'10':400},'5':{'2':240,'4':320,'10':480,'11':320}, '6':{'3':320,'7':80,'8':80},
         '7':{'4':240,'6':80,'9':80}, '8':{'6':80,'9':80}, '9':{'7':80,'8':80,'10':240},
         '10':{'4':400,'5':480,'9':240,'11':320,'12':240}, '11':{'5':320,'10':320,'12':240,'14':240}, '12':{'10':240,'11':240,'13':80},
         '13':{'12':80,'14':160}, '14':{'11':240,'13':160}
         } 
graphnormD = {'1':{'2':400,'3':160,'4':160},'2':{'1':400,'4':400,'5':240},'3':{'1':160,'4':160,'6':320},    
         '4':{'1':160,'2':400,'3':160,'5':320,'7':240,'10':400},'5':{'2':240,'4':320,'10':480,'11':320}, '6':{'3':320,'7':80,'8':80},
         '7':{'4':240,'6':80,'9':80}, '8':{'6':80,'9':80}, '9':{'7':80,'8':80,'10':240},
         '10':{'4':400,'5':480,'9':240,'11':320,'12':240}, '11':{'5':320,'10':320,'12':240,'14':240}, '12':{'10':240,'11':240,'13':80},
         '13':{'12':80,'14':160}, '14':{'11':240,'13':160}
         } 
edgesD = {'1':{'2':0,'3':1,'4':2},'2':{'1':3,'4':4,'5':5},'3':{'1':6,'4':7,'6':8},    
         '4':{'1':9,'2':10,'3':11,'5':12,'7':13,'10':14},'5':{'2':15,'4':16,'10':17,'11':18}, '6':{'3':19,'7':20,'8':21},
         '7':{'4':22,'6':23,'9':24}, '8':{'6':25,'9':26}, '9':{'7':27,'8':28,'10':29},
         '10':{'4':30,'5':31,'9':32,'11':33,'12':34}, '11':{'5':35,'10':36,'12':37,'14':38}, '12':{'10':39,'11':40,'13':41},
         '13':{'12':42,'14':43}, '14':{'11':44,'13':45}
         } 
numedgesD = 46
LspansD = 80

nodesAL = ['1','2','3','4','5','6','7','8','9','10','11']

graphAL = {'1':{'4':1200,'5':1600},'2':{'3':1100,'7':300},'3':{'2':1100,'8':300},    
         '4':{'1':1200,'5':1500,'9':500},'5':{'1':1600,'4':1500,'6':900}, '6':{'5':900,'7':700,'11':1000},
         '7':{'2':300,'6':700,'10':1100}, '8':{'3':300,'10':900}, '9':{'4':500,'11':2200},
         '10':{'7':1100,'8':900,'11':1100}, '11':{'6':1000,'9':2200,'10':1100}
         } 
graphnormAL = {'1':{'4':1200,'5':1600},'2':{'3':1100,'7':300},'3':{'2':1100,'8':300},    
         '4':{'1':1200,'5':1500,'9':500},'5':{'1':1600,'4':1500,'6':900}, '6':{'5':900,'7':700,'11':1000},
         '7':{'2':300,'6':700,'10':1100}, '8':{'3':300,'10':900}, '9':{'4':500,'11':2200},
         '10':{'7':1100,'8':900,'11':1100}, '11':{'6':1000,'9':2200,'10':1100}
         } 
edgesAL = {'1':{'4':0,'5':1},'2':{'3':2,'7':3},'3':{'2':4,'8':5},    
         '4':{'1':6,'5':7,'9':8},'5':{'1':9,'4':10,'6':11}, '6':{'5':12,'7':13,'11':14},
         '7':{'2':15,'6':16,'10':17}, '8':{'3':18,'10':19}, '9':{'4':20,'11':21},
         '10':{'7':22,'8':23,'11':24}, '11':{'6':25,'9':26,'10':27}
         } 
numedgesAL = 28
LspansAL = 100
# choose 'active' topology 
graphA = graphAL
if graphA == graphN:
    graphnormA = graphnormN
    numedgesA = numedgesN
    nodesA = nodesN
    edgesA = edgesN
    LspansA = LspansN
elif graphA == graphD:
    graphnormA = graphnormD
    numedgesA = numedgesD
    nodesA = nodesD
    edgesA = edgesD
    LspansA = LspansD
elif graphA == graphAL:
    graphnormA = graphnormAL
    numedgesA = numedgesAL
    nodesA = nodesAL
    edgesA = edgesAL
    LspansA = LspansAL    
def getedgelen(graph,numedges):
    edgelens = np.empty([numedges,1])
    count = 0
    for key in graph:
        for key2 in graph.get(key):
            #print(graph.get(key).get(key2))
            edgelens[count] = graph.get(key).get(key2)
            count = count + 1
    return edgelens 
edgelensA = getedgelen(graphA, numedgesA)
# %%
PchdBm = np.linspace(-10,10,numpoints)
#ripplepertmax = 0.1  # for fixed perturbation between spans 
#ripplepertmin = -0.1
numlam = 80 # initial expected number of wavelengths 
if datagen:
    def routingdatagen2(edgelen,Lspans):
        lam = 1550
        Rs = 32
        f = 299792458/(lam*1e-9) # operating frequency [Hz]
        h = 6.63*1e-34  # Planck's constant [Js] 
        Pun = GNmain(Lspans, 1, numlam, 101, 201, alpha, Disp, PchdBm, NF, NLco,False,numpoints)[0] # }
        Popt = PchdBm[np.argmax(Pun)]                                                   # }could do this outside of function
        Poptind = int(np.argmax(Pun))                                                   # }
        Poptr = np.linspace(Popt-1.5, Popt+1.5, numpoints)
        numspans = int(edgelen/Lspans)
        ripplepert = np.random.uniform(0.1,0.2,numspans+1)
        Poptran = Poptr  +  np.random.uniform(-ripplepert[0], ripplepert[0], numpoints)
        if numspans == 1: # deal with case of one span link (occurs in DTAG)
            Poptfinal = Poptran
        Gnli = np.empty([numspans,numpoints])
        for i in range(numspans):
            Gnli[i] = GNmain(Lspans, 1, numlam, 101, 201, alpha, Disp, Poptran, NF, NLco,False,numpoints)[4]
            #ripplepert = np.random.uniform(0.1,0.2)
            Poptran = Poptran + np.random.uniform(-ripplepert[i+1], ripplepert[i+1], numpoints)
            if i == numspans-2:
                    Poptfinal = Poptran  # select the power that was put into the last span to calculate SNR
        Gnli = np.sum(Gnli,axis=0)
        Pase = NF*h*f*(db2lin(alpha*Lspans) - 1)*Rs*1e9*numspans
        Pch = 1e-3*10**(Poptfinal/10) 
        return lin2db((Pch)/(Pase*np.ones(numpoints) + Gnli*Rs*1e9)), Popt, Poptind, ripplepert
    
    def savedat(edgelens, numedges,Lspans):    
        linkSNR = np.empty([numedges,numpoints])
        linkpert = []
        for i in range(numedges):
            linkSNR[i], linkPopt, linkPoptind, linkpertP = routingdatagen2(edgelens[i],Lspans)
            linkpert.append(linkpertP)       
        linkPch = np.transpose(np.linspace(linkPopt-1.5, linkPopt+1.5, numpoints).reshape(100,1))
        TRxSNR = 26 # add TRx noise of 26dB B2B 
        linkSNR = lin2db( 1/(  1/(db2lin(linkSNR)) + 1/(db2lin(TRxSNR))  ))
        if graphA == graphN:
            np.savetxt('linkSNR.csv', linkSNR, delimiter=',') 
            np.savetxt('linkPch.csv', linkPch, delimiter=',') 
            linkPopt = linkPopt.reshape(1,1)
            np.savetxt('linkPopt.csv', linkPopt, delimiter=',') 
            for p in range(numedges):
                np.savetxt('linkpert' + str(p) + '.csv', linkpert[p], delimiter=',') 
        elif graphA == graphD:
            np.savetxt('linkSNRD.csv', linkSNR, delimiter=',') 
            np.savetxt('linkPchD.csv', linkPch, delimiter=',') 
            linkPopt = linkPopt.reshape(1,1)
            np.savetxt('linkPoptD.csv', linkPopt, delimiter=',') 
            for p in range(numedges):
                np.savetxt('linkpertD' + str(p) + '.csv', linkpert[p], delimiter=',') 
        elif graphA == graphAL:
            np.savetxt('linkSNRAL.csv', linkSNR, delimiter=',') 
            np.savetxt('linkPchAL.csv', linkPch, delimiter=',') 
            linkPopt = linkPopt.reshape(1,1)
            np.savetxt('linkPoptAL.csv', linkPopt, delimiter=',') 
            for p in range(numedges):
                np.savetxt('linkpertAL' + str(p) + '.csv', linkpert[p], delimiter=',')   
        return linkSNR, linkPch, linkPopt, linkpert, linkPoptind
    
    linkSNR,linkPch,linkPopt, linkpert, linkPoptind = savedat(edgelensA, numedgesA,LspansA)
if datagen == False:
    def importdat(Lspans, numedges):
        Pun = GNmain(Lspans, 1, numlam, 101, 201, alpha, Disp, PchdBm, NF, NLco,False,numpoints)[0] # }
        Popt = PchdBm[np.argmax(Pun)]                                                   # }could do this outside of function
        linkPoptind = int(np.argmax(Pun)) 
        if graphA == graphN:
            linkSNR = np.genfromtxt(open("linkSNR.csv", "r"), delimiter=",", dtype =float)
            linkPch = np.genfromtxt(open("linkPch.csv", "r"), delimiter=",", dtype =float)
            linkpert = []
            linkPopt = np.genfromtxt(open("linkPopt.csv", "r"), delimiter=",", dtype =float)
            for p in range(numedges):
                pert = np.genfromtxt(open("linkpert"  + str(p) + ".csv", "r"), delimiter=",", dtype =float)
                linkpert.append(pert)
        elif graphA == graphD:
            linkSNR = np.genfromtxt(open("linkSNRD.csv", "r"), delimiter=",", dtype =float)
            linkPch = np.genfromtxt(open("linkPchD.csv", "r"), delimiter=",", dtype =float)
            linkpert = []
            linkPopt = np.genfromtxt(open("linkPoptD.csv", "r"), delimiter=",", dtype =float)
            for p in range(numedges):
                pert = np.genfromtxt(open("linkpertD"  + str(p) + ".csv", "r"), delimiter=",", dtype =float)
                linkpert.append(pert)
        elif graphA == graphAL:
            linkSNR = np.genfromtxt(open("linkSNRAL.csv", "r"), delimiter=",", dtype =float)
            linkPch = np.genfromtxt(open("linkPchAL.csv", "r"), delimiter=",", dtype =float)
            linkpert = []
            linkPopt = np.genfromtxt(open("linkPoptAL.csv", "r"), delimiter=",", dtype =float)
            for p in range(numedges):
                pert = np.genfromtxt(open("linkpertAL"  + str(p) + ".csv", "r"), delimiter=",", dtype =float)
                linkpert.append(pert)
                
        return linkSNR, linkPch, linkpert, linkPopt, linkPoptind, Popt

    linkSNR, linkPch, linkpert, linkPopt, linkPoptind, Popt = importdat(LspansA,numedgesA)

# %% import trained GP models
if graphA == graphN:
    prmn = np.genfromtxt(open("prmn.csv", "r"), delimiter=",", dtype =float)
    sigma = np.genfromtxt(open("sig.csv", "r"), delimiter=",", dtype =float)
    sigrf = np.genfromtxt(open("sigrf.csv", "r"), delimiter=",", dtype =float)
elif graphA == graphD:
    prmn = np.genfromtxt(open("prmnD.csv", "r"), delimiter=",", dtype =float)
    sigma = np.genfromtxt(open("sigD.csv", "r"), delimiter=",", dtype =float)
    sigrf = np.genfromtxt(open("sigrfD.csv", "r"), delimiter=",", dtype =float)
elif graphA == graphAL:
    prmn = np.genfromtxt(open("prmnAL.csv", "r"), delimiter=",", dtype =float)
    sigma = np.genfromtxt(open("sigAL.csv", "r"), delimiter=",", dtype =float)
    sigrf = np.genfromtxt(open("sigrfAL.csv", "r"), delimiter=",", dtype =float)

# find optimum from the predictive mean
def vargraphcalcs(prmn,sigma,edgelens):
    prmnopt = [np.argmax(prmn[i]) for i in range(np.size(prmn,0))]
    gsige = [sigma[i][prmnopt[i]] for i in range(np.size(prmn,0))]  # use predictive mean to get optimum Pch
    gwte = [edgelens[i]*gsige[i] for i in range(np.size(prmn,0))]
    gsig = [sigma[i][linkPoptind] for i in range(np.size(sigma,0))]
    gwt = [edgelens[i]*gsig[i] for i in range(np.size(sigma,0))]
    return prmnopt, gsige, gwte, gsig, gwt

prmnopt, gsige, gwte, gsig, gwt = vargraphcalcs(prmn, sigma, edgelensA)

if graphA == graphN:

    graphvar = {'1':{'2':gwt[0][0],'3':gwt[1][0],'8':gwt[2][0]},'2':{'1':gwt[3][0],'3':gwt[4][0],'4':gwt[5][0]},'3':{'1':gwt[6][0],'2':gwt[7][0],'6':gwt[8][0]},    
                 '4':{'2':gwt[9][0],'5':gwt[10][0],'11':gwt[11][0]},'5':{'4':gwt[12][0],'6':gwt[13][0],'7':gwt[14][0]}, '6':{'3':gwt[15][0],'5':gwt[16][0],'10':gwt[17][0],'14':gwt[18][0]},
                 '7':{'5':gwt[19][0],'8':gwt[20][0],'10':gwt[21][0]}, '8':{'1':gwt[22][0],'7':gwt[23][0],'9':gwt[24][0]}, '9':{'8':gwt[25][0],'10':gwt[26][0],'12':gwt[27][0],'13':gwt[28][0]},
                 '10':{'6':gwt[29][0],'7':gwt[30][0],'9':gwt[31][0]}, '11':{'4':gwt[32][0],'12':gwt[33][0],'13':gwt[34][0]}, '12':{'9':gwt[35][0],'11':gwt[36][0],'14':gwt[37][0]},
                 '13':{'9':gwt[38][0],'11':gwt[39][0],'14':gwt[40][0]}, '14':{'6':gwt[41][0],'12':gwt[42][0],'13':gwt[43][0]}
                 }        
    graphvared = {'1':{'2':gwte[0][0],'3':gwte[1][0],'8':gwte[2][0]},'2':{'1':gwte[3][0],'3':gwte[4][0],'4':gwte[5][0]},'3':{'1':gwte[6][0],'2':gwte[7][0],'6':gwte[8][0]},    
                 '4':{'2':gwte[9][0],'5':gwte[10][0],'11':gwte[11][0]},'5':{'4':gwte[12][0],'6':gwte[13][0],'7':gwte[14][0]}, '6':{'3':gwte[15][0],'5':gwte[16][0],'10':gwte[17][0],'14':gwte[18][0]},
                 '7':{'5':gwte[19][0],'8':gwte[20][0],'10':gwte[21][0]}, '8':{'1':gwte[22][0],'7':gwte[23][0],'9':gwte[24][0]}, '9':{'8':gwte[25][0],'10':gwte[26][0],'12':gwte[27][0],'13':gwte[28][0]},
                 '10':{'6':gwte[29][0],'7':gwte[30][0],'9':gwte[31][0]}, '11':{'4':gwte[32][0],'12':gwt[33][0],'13':gwt[34][0]}, '12':{'9':gwte[35][0],'11':gwte[36][0],'14':gwte[37][0]},
                 '13':{'9':gwte[38][0],'11':gwte[39][0],'14':gwte[40][0]}, '14':{'6':gwte[41][0],'12':gwte[42][0],'13':gwte[43][0]}
                 } 
elif graphA == graphD:
    graphvar = {'1':{'2':gwt[0][0],'3':gwt[1][0],'4':gwt[2][0]},'2':{'1':gwt[3][0],'4':gwt[4][0],'5':gwt[5][0]},'3':{'1':gwt[6][0],'4':gwt[7][0],'6':gwt[8][0]},    
         '4':{'1':gwt[9][0],'2':gwt[10][0],'3':gwt[11][0],'5':gwt[12][0],'7':gwt[13][0],'10':gwt[14][0]},'5':{'2':gwt[15][0],'4':gwt[16][0],'10':gwt[17][0],'11':gwt[18][0]}, '6':{'3':gwt[19][0],'7':gwt[20][0],'8':gwt[21][0]},
         '7':{'4':gwt[22][0],'6':gwt[23][0],'9':gwt[24][0]}, '8':{'6':gwt[25][0],'9':gwt[26][0]}, '9':{'7':gwt[27][0],'8':gwt[28][0],'10':gwt[29][0]},
         '10':{'4':gwt[30][0],'5':gwt[31][0],'9':gwt[32][0],'11':gwt[33][0],'12':gwt[34][0]}, '11':{'5':gwt[35][0],'10':gwt[36][0],'12':gwt[37][0],'14':gwt[38][0]}, '12':{'10':gwt[39][0],'11':gwt[40][0],'13':gwt[41][0]},
         '13':{'12':gwt[42][0],'14':gwt[43][0]}, '14':{'11':gwt[44][0],'13':gwt[45][0]}
         } 
    graphvared = {'1':{'2':gwte[0][0],'3':gwte[1][0],'4':gwte[2][0]},'2':{'1':gwte[3][0],'4':gwte[4][0],'5':gwte[5][0]},'3':{'1':gwte[6][0],'4':gwte[7][0],'6':gwte[8][0]},    
         '4':{'1':gwte[9][0],'2':gwte[10][0],'3':gwte[11][0],'5':gwte[12][0],'7':gwte[13][0],'10':gwte[14][0]},'5':{'2':gwte[15][0],'4':gwte[16][0],'10':gwte[17][0],'11':gwte[18][0]}, '6':{'3':gwte[19][0],'7':gwte[20][0],'8':gwte[21][0]},
         '7':{'4':gwte[22][0],'6':gwte[23][0],'9':gwte[24][0]}, '8':{'6':gwte[25][0],'9':gwte[26][0]}, '9':{'7':gwte[27][0],'8':gwte[28][0],'10':gwte[29][0]},
         '10':{'4':gwte[30][0],'5':gwte[31][0],'9':gwte[32][0],'11':gwte[33][0],'12':gwte[34][0]}, '11':{'5':gwte[35][0],'10':gwte[36][0],'12':gwte[37][0],'14':gwte[38][0]}, '12':{'10':gwte[39][0],'11':gwte[40][0],'13':gwte[41][0]},
         '13':{'12':gwte[42][0],'14':gwte[43][0]}, '14':{'11':gwte[44][0],'13':gwte[45][0]}
         } 
    
elif graphA == graphAL:
    graphvar = {'1':{'4':gwt[0][0],'5':gwt[1][0]},'2':{'3':gwt[2][0],'7':gwt[3][0]},'3':{'2':gwt[4][0],'8':gwt[5][0]},    
         '4':{'1':gwt[6][0],'5':gwt[7][0],'9':gwt[8][0]},'5':{'1':gwt[9][0],'4':gwt[10][0],'6':gwt[11][0]}, '6':{'5':gwt[12][0],'7':gwt[13][0],'11':gwt[14][0]},
         '7':{'2':gwt[15][0],'6':gwt[16][0],'10':gwt[17][0]}, '8':{'3':gwt[18][0],'10':gwt[19][0]}, '9':{'4':gwt[20][0],'11':gwt[21][0]},
         '10':{'7':gwt[22][0],'8':gwt[23][0],'11':gwt[24][0]}, '11':{'6':gwt[25][0],'9':gwt[26][0],'10':gwt[27][0]}
         } 
    graphvared = {'1':{'4':gwte[0][0],'5':gwte[1][0]},'2':{'3':gwte[2][0],'7':gwte[3][0]},'3':{'2':gwte[4][0],'8':gwte[5][0]},    
         '4':{'1':gwte[6][0],'5':gwte[7][0],'9':gwte[8][0]},'5':{'1':gwte[9][0],'4':gwte[10][0],'6':gwte[11][0]}, '6':{'5':gwte[12][0],'7':gwte[13][0],'11':gwte[14][0]},
         '7':{'2':gwte[15][0],'6':gwte[16][0],'10':gwte[17][0]}, '8':{'3':gwte[18][0],'10':gwte[19][0]}, '9':{'4':gwte[20][0],'11':gwte[21][0]},
         '10':{'7':gwte[22][0],'8':gwte[23][0],'11':gwte[24][0]}, '11':{'6':gwte[25][0],'9':gwte[26][0],'10':gwte[27][0]}
         } 

def fmsnr(edgelen, Lspans):
    Ls = Lspans
    NchNy = numlam
    D = Disp
    gam = NLco
    lam = 1550 # operating wavelength centre [nm]
    f = 299792458/(lam*1e-9) # operating frequency [Hz]
    c = 299792.458 # speed of light in vacuum [nm/ps] -> needed for calculation of beta2
    Rs = 32 # symbol rate [GBaud]
    h = 6.63*1e-34  # Planck's constant [Js]
    BWNy = (NchNy*Rs)/1e3 # full BW of Nyquist signal [THz
    allin = np.log((10**(alpha/10)))/2 # fibre loss [1/km] -> weird definition, due to exponential decay of electric field instead of power, which is standard 
    #gam = 1.27 # fibre nonlinearity coefficient [1/W*km]
    beta2 = (D*(lam**2))/(2*np.pi*c) # dispersion coefficient at given wavelength [ps^2/km]
    Leff = (1 - np.exp(-2*allin*Ls ))/(2*allin)  # effective length [km]      
    Leffa = 1/(2*allin)  # the asymptotic effective length [km]  
    #ripplepert = 0.1
    #ripplepert = np.random.uniform(0.1,0.2,numspans+1)
    numspans = int(edgelen/Lspans)
    Pun = GNmain(Lspans, 1, numlam, 101, 201, alpha, Disp, PchdBm, NF, NLco,False,numpoints)[0] 
    Popt = PchdBm[np.argmax(Pun)]                                                   
    Gwdm = (1e-3*10**(Popt/10)*NchNy)/(BWNy*1e12) # flat-top value of PSD of signal [W/Hz]
    Gnli = 1e24*(8/27)*(gam**2)*(Gwdm**3)*(Leff**2)*((np.arcsinh((np.pi**2)*0.5*beta2*Leffa*(BWNy**2)  ) )/(np.pi*beta2*Leffa ))*numspans
    Pase = NF*h*f*(db2lin(alpha*Lspans) - 1)*Rs*1e9*numspans
    Pch = 1e-3*10**(Popt/10) 
    return lin2db((Pch)/(Pase + Gnli*Rs*1e9)) 
def fmdatagen(edgelens,Lspans):
    fmSNR = np.empty([np.size(edgelens),1])
    for i in range(np.size(edgelens)):
        fmSNR[i] = fmsnr(edgelens[i],Lspans)
    return fmSNR

fmSNR = fmdatagen(edgelensA,LspansA)
# %%
def BERcalc(M, SNR): # linear SNR here is energy per symbol - need to convert to energy per bit to use these formulae - hence the division by log2(M)
        if M == 2: 
            BER = 0.5*special.erfc(((2*SNR)/np.log2(2))**0.5)
        elif M == 4: 
            BER = 0.5*special.erfc(((2*SNR)/np.log2(4))**0.5)    
        elif M == 16:
            BER = (3/8)*special.erfc(((2/5)*(SNR/np.log2(16)))**0.5) + (1/4)*special.erfc(((18/5)*(SNR/np.log2(16)))**0.5) - (1/8)*special.erfc((10*(SNR/np.log2(16)))**0.5)
        elif M == 64:
            BER = (7/24)*special.erfc(((1/7)*(SNR/np.log2(64)))**0.5) + (1/4)*special.erfc(((9/7)*(SNR/np.log2(64)))**0.5) - (1/24)*special.erfc(((25/7)*(SNR/np.log2(64)))**0.5) + (1/24)*special.erfc(((81/7)*(SNR/np.log2(64)))**0.5) - (1/24)*special.erfc(((169/7)*(SNR/np.log2(64)))**0.5) 
        else:
            print("unrecognised modulation format")
        return BER
    
# %%    
    
def getlinklen(shpath,graph,edges):
        linklen = np.empty([len(shpath)-1,1])
        link = []
        for i in range(len(shpath)-1):
            linklen[i] = float((graph.get(shpath[i])).get(shpath[i+1]))
            link.append((edges.get(shpath[i])).get(shpath[i+1]))
        return linklen, link
    
def requestgen(graph):
            src = random.choice(list(graph.keys()))
            des = random.choice(list(graph.keys()))
            while des == src:
                des = random.choice(list(graph.keys()))
            return src, des

def SNRnew(edgelen, ripplepert, Popt, Lspans, numlam):
        Ls = Lspans
        NchNy = numlam
        D = Disp
        gam = NLco
        lam = 1550 # operating wavelength centre [nm]
        f = 299792458/(lam*1e-9) # operating frequency [Hz]
        c = 299792.458 # speed of light in vacuum [nm/ps] -> needed for calculation of beta2
        Rs = 32 # symbol rate [GBaud]
        h = 6.63*1e-34  # Planck's constant [Js]
        BWNy = (NchNy*Rs)/1e3 # full BW of Nyquist signal [THz
        allin = np.log((10**(alpha/10)))/2 # fibre loss [1/km] -> weird definition, due to exponential decay of electric field instead of power, which is standard 
        #gam = 1.27 # fibre nonlinearity coefficient [1/W*km]
        beta2 = (D*(lam**2))/(2*np.pi*c) # dispersion coefficient at given wavelength [ps^2/km]
        Leff = (1 - np.exp(-2*allin*Ls ))/(2*allin)  # effective length [km]      
        Leffa = 1/(2*allin)  # the asymptotic effective length [km]  
        #ripplepert = 0.1
        #ripplepert = np.random.uniform(0.1,0.2,numspans+1)
        numspans = int(edgelen/Lspans)
        Poptran = Popt  +  np.random.uniform(-ripplepert[0], ripplepert[0])
        if numspans == 1:
            Poptfinal = Poptran
        Gnli = np.empty([numspans,1])
        for i in range(numspans):
            Gwdm = (1e-3*10**(Poptran/10)*NchNy)/(BWNy*1e12) # flat-top value of PSD of signal [W/Hz]
            Gnli[i] = 1e24*(8/27)*(gam**2)*(Gwdm**3)*(Leff**2)*((np.arcsinh((np.pi**2)*0.5*beta2*Leffa*(BWNy**2)  ) )/(np.pi*beta2*Leffa ))
            #ripplepert = np.random.uniform(0.1,0.2)
            Poptran = Poptran + np.random.uniform(-ripplepert[i+1], ripplepert[i+1])
            if i == numspans-2:
                    Poptfinal = Poptran  # select the power that was put into the last span to calculate SNR
        Gnli = np.sum(Gnli,axis=0)
        Pase = NF*h*f*(db2lin(alpha*Lspans) - 1)*Rs*1e9*numspans
        Pch = 1e-3*10**(Poptfinal/10) 
        return lin2db((Pch)/(Pase + Gnli*Rs*1e9))

FT2 = 0.24
FT4 = 3.25 # all correspond to BER of 2e-2
FT16 = 12.72
FT64 = 18.43
FT128 = 22.35
       
# %% fixed margin routing algorithm 
# margin = 6.3 # BoL
margin = 6.3 # EoL (design only)
def fmrta(graph, edges, Rsource, Rdest, showres, margin,nodes,numedges,edgelens,fmSNR, Lspans):
    dis = []
    path = []
    numnodes = np.size(nodes)
    if graphA == graphN:
        for i in range(numnodes):    
            for j in range(numnodes): 
                d, p = dijkstra({'1':{'2':2100,'3':3000,'8':4800},'2':{'1':2100,'3':1200,'4':1500},'3':{'1':3000,'2':1200,'6':3600},    
                 '4':{'2':1500,'5':1200,'11':3900},'5':{'4':1200,'6':2400,'7':1200}, '6':{'3':3600,'5':2400,'10':2100,'14':3600},
                 '7':{'5':1200,'8':1500,'10':2700}, '8':{'1':4800,'7':1500,'9':1500}, '9':{'8':1500,'10':1500,'12':600,'13':600},
                 '10':{'6':2100,'7':2700,'9':1500}, '11':{'4':3900,'12':1200,'13':1500}, '12':{'9':600,'11':1200,'14':600},
                 '13':{'9':600,'11':1500,'14':300}, '14':{'6':3600,'12':600,'13':300}
                 }, nodes[i], nodes[j])
                if i == j:
                    continue  # don't include lightpaths of length 0
                else:
                    dis.append(d)
                    path.append(p)
    elif graphA == graphD:
        for i in range(numnodes):    
            for j in range(numnodes): 
                d, p = dijkstra({'1':{'2':400,'3':160,'4':160},'2':{'1':400,'4':400,'5':240},'3':{'1':160,'4':160,'6':320},    
                '4':{'1':160,'2':400,'3':160,'5':320,'7':240,'10':400},'5':{'2':240,'4':320,'10':480,'11':320}, '6':{'3':320,'7':80,'8':80},
                '7':{'4':240,'6':80,'9':80}, '8':{'6':80,'9':80}, '9':{'7':80,'8':80,'10':240},
                '10':{'4':400,'5':480,'9':240,'11':320,'12':240}, '11':{'5':320,'10':320,'12':240,'14':240}, '12':{'10':240,'11':240,'13':80},
                '13':{'12':80,'14':160}, '14':{'11':240,'13':160}
                } , nodes[i], nodes[j])
                if i == j:
                    continue  # don't include lightpaths of length 0
                else:
                    dis.append(d)
                    path.append(p)
    elif graphA == graphAL:
        for i in range(numnodes):    
            for j in range(numnodes): 
                d, p = dijkstra({'1':{'4':1200,'5':1600},'2':{'3':1100,'7':300},'3':{'2':1100,'8':300},    
                '4':{'1':1200,'5':1500,'9':500},'5':{'1':1600,'4':1500,'6':900}, '6':{'5':900,'7':700,'11':1000},
                '7':{'2':300,'6':700,'10':1100}, '8':{'3':300,'10':900}, '9':{'4':500,'11':2200},
                '10':{'7':1100,'8':900,'11':1100}, '11':{'6':1000,'9':2200,'10':1100}
                }  , nodes[i], nodes[j])
                if i == j:
                    continue  # don't include lightpaths of length 0
                else:
                    dis.append(d)
                    path.append(p)
    pathdists = []
    links = []                                                
    for i in range(np.size(path)):
        pathdists.append(getlinklen(path[i],graphnormA,edges)[0])
        links.append(getlinklen(path[i],graph,edges)[1])
    
    estlam = np.zeros([numedges,numlam]) # 0 for empty, 1 for occupied
    reqlams = 0
    conten = 0
    failures = 0 # post-reach determination failures
    noreach = 0 # cases in which algorithm unable to assign any modulation 
    ct128 = 0
    ct64 = 0
    ct16 = 0
    ct4 = 0
    ct2 = 0
    numreq = np.size(Rsource)
    randdist = []
    for i in range(numreq):
        # update for online learning 
        #  choose random source and destination nodes 
    
        # find corresponding path index
        def srcdestcheck(path,src,dest):
            if path[0] == src and path[-1] == dest:
                return True  
        
        randpathind = [j for j in range(np.size(path)) if  srcdestcheck(path[j], Rsource[i], Rdest[i])][0]
        #print("selected request index: " + str(randpathind))
        randedges = links[randpathind]  # selected edges for request 
        randdist.append(sum(pathdists[randpathind]))
        lamconten = False
        testlamslot = [np.where(estlam[randedges[k]]==0) for k in range(np.size(randedges))]
        for g in range(np.size(randedges)):
            if np.size(testlamslot[g]) == 0:
                #print("all wavelength slots are full")
                lamconten = True
                continue
        if lamconten:
            conten = conten + 1
            continue
        lamslot = [np.where(estlam[randedges[k]]==0)[0][0] for k in range(np.size(randedges))] # first available wavelength slot for this edge
        
        # need to check SNR for all the edges in the path
        edgesuc = 0
        edgesuc2 = 0
        FT = np.zeros(np.size(linkSNR[randedges],0))
        #print(np.size(linkSNR[randedges],0))
        #print(np.size(randedges))
        for j in range(np.size(linkSNR[randedges],0)):
            
            if fmSNR[randedges][j] - margin > FT128:
                FT[j] = FT128
                ct128 = ct128 + 1
                edgesuc = edgesuc + 1
            elif fmSNR[randedges][j] - margin > FT64:
                FT[j] = FT64
                ct64 = ct64 + 1
                edgesuc = edgesuc + 1
            elif fmSNR[randedges][j] - margin > FT16:
                FT[j] = FT16
                ct16 = ct16 + 1
                edgesuc = edgesuc + 1
            elif fmSNR[randedges][j] - margin > FT4:
                FT[j] = FT4
                ct4 = ct4 + 1
                edgesuc = edgesuc + 1
            elif fmSNR[randedges][j] - margin > FT2:
                FT[j] = FT2
                ct2 = ct2 + 1
                edgesuc = edgesuc + 1
            else:
                #print("request " + str(i) + " denied -- insufficient reach on edge " + str(randedges[j]))
                break   
        
        if edgesuc == np.size(linkSNR[randedges],0):
            # generate new SNR value here
            for w in range(np.size(randedges)):
                # retrieve estlam row corresponding to randegdes[w] index, find number of 1s, pass to SNRnew()
                estSNR = SNRnew(edgelens[randedges[w]], linkpert[randedges[w]], linkPopt, Lspans, np.count_nonzero(estlam[randedges[w]])+1 )
                if estSNR > FT[w]:
                    # link successfully established
                    edgesuc2 = edgesuc2 + 1
            if edgesuc2 == np.size(randedges):
                # path successfully established
                reqlams = reqlams + 1
                for l in range(len(randedges)):
                    estlam[randedges[l]][lamslot[l]] = 1
            else: 
                # link not established
                failures = failures + 1
        
        else: 
            noreach = noreach + 1
        
    ava = (reqlams/numreq)*100 
    tottime = (sum(randdist)*1e3*1.468)/299792458
    if showres:
        print("Normal availability = " + str(ava) + "%") 
        print("Normal total traversal time = " + str('%.2f' % tottime) + "s")
        print("Normal number of failures = " + str(failures))
    return ava, estlam, reqlams, tottime, conten,ct128, ct64, ct16, ct4,ct2, failures, noreach
# =============================================================================
# testsrc = []
# testdes = []
# for _ in range(80):
#     rsctest, rdstest = requestgen(graphA)
#     testsrc.append(rsctest)
#     testdes.append(rdstest)
# test1, test2, test3, test4, test5, test6, test7, test8, test9, test10, test11, test12 = fmrta(graphA, edgesA, testsrc, testdes, False, margin,nodesA,numedgesA,edgelensA,fmSNR, LspansA)
# =============================================================================
# %%
# generate shortest path between each pair of nodes and store the path and distance
def basicrta(graph, edges, Rsource, Rdest, showres, nodes,numedges,edgelens,Lspans):
    dis = []
    path = []
    numnodes = np.size(nodes)
    if graphA == graphN:
        for i in range(numnodes):    
            for j in range(numnodes): 
                d, p = dijkstra({'1':{'2':2100,'3':3000,'8':4800},'2':{'1':2100,'3':1200,'4':1500},'3':{'1':3000,'2':1200,'6':3600},    
                 '4':{'2':1500,'5':1200,'11':3900},'5':{'4':1200,'6':2400,'7':1200}, '6':{'3':3600,'5':2400,'10':2100,'14':3600},
                 '7':{'5':1200,'8':1500,'10':2700}, '8':{'1':4800,'7':1500,'9':1500}, '9':{'8':1500,'10':1500,'12':600,'13':600},
                 '10':{'6':2100,'7':2700,'9':1500}, '11':{'4':3900,'12':1200,'13':1500}, '12':{'9':600,'11':1200,'14':600},
                 '13':{'9':600,'11':1500,'14':300}, '14':{'6':3600,'12':600,'13':300}
                 }, nodes[i], nodes[j])
                if i == j:
                    continue  # don't include lightpaths of length 0
                else:
                    dis.append(d)
                    path.append(p)
    elif graphA == graphD:
        for i in range(numnodes):    
            for j in range(numnodes): 
                d, p = dijkstra({'1':{'2':400,'3':160,'4':160},'2':{'1':400,'4':400,'5':240},'3':{'1':160,'4':160,'6':320},    
                '4':{'1':160,'2':400,'3':160,'5':320,'7':240,'10':400},'5':{'2':240,'4':320,'10':480,'11':320}, '6':{'3':320,'7':80,'8':80},
                '7':{'4':240,'6':80,'9':80}, '8':{'6':80,'9':80}, '9':{'7':80,'8':80,'10':240},
                '10':{'4':400,'5':480,'9':240,'11':320,'12':240}, '11':{'5':320,'10':320,'12':240,'14':240}, '12':{'10':240,'11':240,'13':80},
                '13':{'12':80,'14':160}, '14':{'11':240,'13':160}
                } , nodes[i], nodes[j])
                if i == j:
                    continue  # don't include lightpaths of length 0
                else:
                    dis.append(d)
                    path.append(p)
    elif graphA == graphAL:
        for i in range(numnodes):    
            for j in range(numnodes): 
                d, p = dijkstra({'1':{'4':1200,'5':1600},'2':{'3':1100,'7':300},'3':{'2':1100,'8':300},    
                '4':{'1':1200,'5':1500,'9':500},'5':{'1':1600,'4':1500,'6':900}, '6':{'5':900,'7':700,'11':1000},
                '7':{'2':300,'6':700,'10':1100}, '8':{'3':300,'10':900}, '9':{'4':500,'11':2200},
                '10':{'7':1100,'8':900,'11':1100}, '11':{'6':1000,'9':2200,'10':1100}
                }  , nodes[i], nodes[j])
                if i == j:
                    continue  # don't include lightpaths of length 0
                else:
                    dis.append(d)
                    path.append(p)
    pathdists = []
    links = []                                                
    for i in range(np.size(path)):
        pathdists.append(getlinklen(path[i],graphnormA,edges)[0])
        links.append(getlinklen(path[i],graph,edges)[1])
    
    estlam = np.zeros([numedges,numlam]) # 0 for empty, 1 for occupied
    reqlams = 0
    conten = 0
    failures = 0
    ct128 = 0
    ct64 = 0
    ct16 = 0
    ct4 = 0
    ct2 = 0
    numreq = np.size(Rsource)
    randdist = []
    for i in range(numreq):
        # update for online learning 
        # choose random source and destination nodes 
        # find corresponding path index
        def srcdestcheck(path,src,dest):
            if path[0] == src and path[-1] == dest:
                return True  
        
        randpathind = [j for j in range(np.size(path)) if  srcdestcheck(path[j], Rsource[i], Rdest[i])][0]
        #print("selected request index: " + str(randpathind))
        randedges = links[randpathind]  # selected edges for request 
        randdist.append(sum(pathdists[randpathind]))
        lamconten = False
        testlamslot = [np.where(estlam[randedges[k]]==0) for k in range(np.size(randedges))]
        for g in range(np.size(randedges)):
            if np.size(testlamslot[g]) == 0:
                #print("all wavelength slots are full")
                lamconten = True
                continue
        if lamconten:
            conten = conten + 1
            continue
        lamslot = [np.where(estlam[randedges[k]]==0)[0][0] for k in range(np.size(randedges))] # first available wavelength slot for this edge
        # need to check SNR for all the edges in the path
        edgesuc = 0
        edgesuc2 = 0
        FT = np.zeros(np.size(linkSNR[randedges],0))
        #print(np.size(linkSNR[randedges],0))
        #print(np.size(randedges))
        for j in range(np.size(linkSNR[randedges],0)):
            
            if linkSNR[randedges][j][linkPoptind] > FT128:
                FT[j] = FT128
                ct128 = ct128 + 1
                edgesuc = edgesuc + 1
            elif linkSNR[randedges][j][linkPoptind] > FT64:
                FT[j] = FT64
                ct64 = ct64 + 1
                edgesuc = edgesuc + 1
            elif linkSNR[randedges][j][linkPoptind] > FT16:
                FT[j] = FT16
                ct16 = ct16 + 1
                edgesuc = edgesuc + 1
            elif linkSNR[randedges][j][linkPoptind] > FT4:
                FT[j] = FT4
                ct4 = ct4 + 1
                edgesuc = edgesuc + 1
            elif linkSNR[randedges][j][linkPoptind] > FT2:
                FT[j] = FT2
                ct2 = ct2 + 1
                edgesuc = edgesuc + 1
            else:
                #print("request " + str(i) + " denied -- insufficient reach on edge " + str(randedges[j]))
                break   
        if edgesuc == np.size(linkSNR[randedges],0):
            # generate new SNR value here
            for w in range(np.size(randedges)):
                # retrieve estlam row corresponding to randegdes[w] index, find number of 1s, pass to SNRnew()
                estSNR = SNRnew(edgelens[randedges[w]], linkpert[randedges[w]], linkPopt,Lspans, np.count_nonzero(estlam[randedges[w]])+1 )
                if estSNR > FT[w]:
                    # link successfully established
                    edgesuc2 = edgesuc2 + 1
            if edgesuc2 == np.size(randedges):
                # path successfully established
                reqlams = reqlams + 1
                for l in range(len(randedges)):
                    estlam[randedges[l]][lamslot[l]] = 1
            else: 
                # link not established
                failures = failures + 1
    ava = (reqlams/numreq)*100 
    tottime = (sum(randdist)*1e3*1.468)/299792458
    if showres:
        print("Normal availability = " + str(ava) + "%") 
        print("Normal total traversal time = " + str('%.2f' % tottime) + "s")
        print("Normal number of failures = " + str(failures))
    return ava, estlam, reqlams, tottime, conten, ct128, ct64, ct16, ct4,ct2, failures
#test1, test2, test3, _, _,test4, test5, test6 = basicrta(graphA, edgesA, Rsource, Rdest, False, nodes,numedges,edgelens,Lspans)
# %%
def varrta(graph,edges,Rsource,Rdest,showres,nodes,numedges,edgelens,Lspans):
    dis = []
    path = []
    numnodes = np.size(nodes)
    if graphA == graphN:
        for i in range(numnodes):    
            for j in range(numnodes): 
                d, p = dijkstra({'1':{'2':gwt[0][0],'3':gwt[1][0],'8':gwt[2][0]},'2':{'1':gwt[3][0],'3':gwt[4][0],'4':gwt[5][0]},'3':{'1':gwt[6][0],'2':gwt[7][0],'6':gwt[8][0]},    
                 '4':{'2':gwt[9][0],'5':gwt[10][0],'11':gwt[11][0]},'5':{'4':gwt[12][0],'6':gwt[13][0],'7':gwt[14][0]}, '6':{'3':gwt[15][0],'5':gwt[16][0],'10':gwt[17][0],'14':gwt[18][0]},
                 '7':{'5':gwt[19][0],'8':gwt[20][0],'10':gwt[21][0]}, '8':{'1':gwt[22][0],'7':gwt[23][0],'9':gwt[24][0]}, '9':{'8':gwt[25][0],'10':gwt[26][0],'12':gwt[27][0],'13':gwt[28][0]},
                 '10':{'6':gwt[29][0],'7':gwt[30][0],'9':gwt[31][0]}, '11':{'4':gwt[32][0],'12':gwt[33][0],'13':gwt[34][0]}, '12':{'9':gwt[35][0],'11':gwt[36][0],'14':gwt[37][0]},
                 '13':{'9':gwt[38][0],'11':gwt[39][0],'14':gwt[40][0]}, '14':{'6':gwt[41][0],'12':gwt[42][0],'13':gwt[43][0]}
                 }, nodes[i], nodes[j])
                if i == j:
                    continue  # don't include lightpaths of length 0
                else:
                    dis.append(d)
                    path.append(p)
    elif graphA == graphD: 
        for i in range(numnodes):    
            for j in range(numnodes): 
                d, p = dijkstra({'1':{'2':gwt[0][0],'3':gwt[1][0],'4':gwt[2][0]},'2':{'1':gwt[3][0],'4':gwt[4][0],'5':gwt[5][0]},'3':{'1':gwt[6][0],'4':gwt[7][0],'6':gwt[8][0]},    
                '4':{'1':gwt[9][0],'2':gwt[10][0],'3':gwt[11][0],'5':gwt[12][0],'7':gwt[13][0],'10':gwt[14][0]},'5':{'2':gwt[15][0],'4':gwt[16][0],'10':gwt[17][0],'11':gwt[18][0]}, '6':{'3':gwt[19][0],'7':gwt[20][0],'8':gwt[21][0]},
                '7':{'4':gwt[22][0],'6':gwt[23][0],'9':gwt[24][0]}, '8':{'6':gwt[25][0],'9':gwt[26][0]}, '9':{'7':gwt[27][0],'8':gwt[28][0],'10':gwt[29][0]},
                '10':{'4':gwt[30][0],'5':gwt[31][0],'9':gwt[32][0],'11':gwt[33][0],'12':gwt[34][0]}, '11':{'5':gwt[35][0],'10':gwt[36][0],'12':gwt[37][0],'14':gwt[38][0]}, '12':{'10':gwt[39][0],'11':gwt[40][0],'13':gwt[41][0]},
                '13':{'12':gwt[42][0],'14':gwt[43][0]}, '14':{'11':gwt[44][0],'13':gwt[45][0]}
                } , nodes[i], nodes[j])
                if i == j:
                    continue  # don't include lightpaths of length 0
                else:
                    dis.append(d)
                    path.append(p)
    elif graphA == graphAL: 
        for i in range(numnodes):    
            for j in range(numnodes): 
                d, p = dijkstra({'1':{'4':gwt[0][0],'5':gwt[1][0]},'2':{'3':gwt[2][0],'7':gwt[3][0]},'3':{'2':gwt[4][0],'8':gwt[5][0]},    
                '4':{'1':gwt[6][0],'5':gwt[7][0],'9':gwt[8][0]},'5':{'1':gwt[9][0],'4':gwt[10][0],'6':gwt[11][0]}, '6':{'5':gwt[12][0],'7':gwt[13][0],'11':gwt[14][0]},
                '7':{'2':gwt[15][0],'6':gwt[16][0],'10':gwt[17][0]}, '8':{'3':gwt[18][0],'10':gwt[19][0]}, '9':{'4':gwt[20][0],'11':gwt[21][0]},
                '10':{'7':gwt[22][0],'8':gwt[23][0],'11':gwt[24][0]}, '11':{'6':gwt[25][0],'9':gwt[26][0],'10':gwt[27][0]}
                } , nodes[i], nodes[j])
                if i == j:
                    continue  # don't include lightpaths of length 0
                else:
                    dis.append(d)
                    path.append(p)
    pathdists = []
    links = []                                                
    for i in range(np.size(path)):
        pathdists.append(getlinklen(path[i],graphnormA,edges)[0])
        links.append(getlinklen(path[i],graph,edges)[1])
    
    estlam = np.zeros([numedges,numlam]) # 0 for empty, 1 for occupied
    reqlams = 0
    conten = 0
    failures = 0
    ct128 = 0
    ct64 = 0
    ct16 = 0
    ct4 = 0
    ct2 = 0
    numreq = np.size(Rsource)
    randdist = []
    for i in range(numreq):
        # update for online learning 
        #  choose random source and destination nodes 
        
        #Rsource, Rdest = requestgen(graph)
        # find corresponding path index
        def srcdestcheck(path,src,dest):
            if path[0] == src and path[-1] == dest:
                return True  

        randpathind = [j for j in range(np.size(path)) if  srcdestcheck(path[j], Rsource[i], Rdest[i])][0]
        #print("selected request index: " + str(randpathind))
        randedges = links[randpathind]  # selected edges for request 
        randdist.append(sum(pathdists[randpathind]))
        lamconten = False
        testlamslot = [np.where(estlam[randedges[k]]==0) for k in range(np.size(randedges))]
        for g in range(np.size(randedges)):
            if np.size(testlamslot[g]) == 0:
                #print("all wavelength slots are full")
                lamconten = True
                continue
        if lamconten:
            conten = conten + 1
            continue
        lamslot = [np.where(estlam[randedges[k]]==0)[0][0] for k in range(np.size(links[randpathind]))] # first available wavelength slot for this edge
        
        # need to check SNR for all the edges in the path
        edgesuc = 0
        edgesuc2 = 0
        FT = np.zeros(np.size(linkSNR[randedges],0))
        for j in range(np.size(linkSNR[randedges],0)):
            if linkSNR[randedges][j][linkPoptind] > FT128:
                FT[j] = FT128
                ct128 = ct128 + 1
                edgesuc = edgesuc + 1
            elif linkSNR[randedges][j][linkPoptind] > FT64:
                FT[j] = FT64
                ct64 = ct64 + 1
                edgesuc = edgesuc + 1
            elif linkSNR[randedges][j][linkPoptind] > FT16:
                FT[j] = FT16
                ct16 = ct16 + 1
                edgesuc = edgesuc + 1
            elif linkSNR[randedges][j][linkPoptind] > FT4:
                FT[j] = FT4
                ct4 = ct4 + 1
                edgesuc = edgesuc + 1
            elif linkSNR[randedges][j][linkPoptind] > FT2:
                FT[j] = FT2
                ct2 = ct2 + 1
                edgesuc = edgesuc + 1
            else:
                #print("request " + str(i) + " denied -- insufficient reach on edge " + str(randedges[j]))
                break   
       
        if edgesuc == np.size(linkSNR[randedges],0):
            # generate new SNR value here
            for w in range(np.size(randedges)):                                
                estSNR = SNRnew(edgelens[randedges[w]], linkpert[randedges[w]], linkPopt, Lspans, np.count_nonzero(estlam[randedges[w]])+1 )
                if estSNR > FT[w]:
                    # link successfully established
                    edgesuc2 = edgesuc2 + 1
            if edgesuc2 == np.size(randedges):
                # path successfully established
                reqlams = reqlams + 1
                for l in range(len(randedges)):
                    estlam[randedges[l]][lamslot[l]] = 1
            else: 
                # link not established
                failures = failures + 1
   
    ava = (reqlams/numreq)*100 
    tottime = ((sum(randdist)*1e3*1.468)/299792458)[0]
    if showres:
        print("Variance-aided availability = " + str(ava) + "%") 
        print("Variance-aided total traversal time = " + str('%.2f' % tottime) + "s")
    return ava, estlam, reqlams, tottime, conten, ct128, ct64, ct16, ct4,ct2, failures


#avav, estlamv, reqlamsv, tottimev  = varrta(FT,graphvar,edges,rsrc,rdes,False)

# %%
def varrtap(graph,edges,Rsource,Rdest,showres,numsig,nodes,numedges,edgelens,Lspans):
    dis = []
    path = []
    numnodes = np.size(nodes)
    if graphA == graphN:
        for i in range(numnodes):    
            for j in range(numnodes): 
                d, p = dijkstra({'1':{'2':gwte[0][0],'3':gwte[1][0],'8':gwte[2][0]},'2':{'1':gwte[3][0],'3':gwte[4][0],'4':gwte[5][0]},'3':{'1':gwte[6][0],'2':gwte[7][0],'6':gwte[8][0]},    
                 '4':{'2':gwte[9][0],'5':gwte[10][0],'11':gwte[11][0]},'5':{'4':gwte[12][0],'6':gwte[13][0],'7':gwte[14][0]}, '6':{'3':gwte[15][0],'5':gwte[16][0],'10':gwte[17][0],'14':gwte[18][0]},
                 '7':{'5':gwte[19][0],'8':gwte[20][0],'10':gwte[21][0]}, '8':{'1':gwte[22][0],'7':gwte[23][0],'9':gwte[24][0]}, '9':{'8':gwte[25][0],'10':gwte[26][0],'12':gwte[27][0],'13':gwte[28][0]},
                 '10':{'6':gwte[29][0],'7':gwte[30][0],'9':gwte[31][0]}, '11':{'4':gwte[32][0],'12':gwt[33][0],'13':gwt[34][0]}, '12':{'9':gwte[35][0],'11':gwte[36][0],'14':gwte[37][0]},
                 '13':{'9':gwte[38][0],'11':gwte[39][0],'14':gwte[40][0]}, '14':{'6':gwte[41][0],'12':gwte[42][0],'13':gwte[43][0]}
                 }, nodes[i], nodes[j])
                if i == j:
                    continue  # don't include lightpaths of length 0
                else:
                    dis.append(d)
                    path.append(p)
    elif graphA == graphD:
        for i in range(numnodes):    
            for j in range(numnodes): 
                d, p = dijkstra({'1':{'2':gwte[0][0],'3':gwte[1][0],'4':gwte[2][0]},'2':{'1':gwte[3][0],'4':gwte[4][0],'5':gwte[5][0]},'3':{'1':gwte[6][0],'4':gwte[7][0],'6':gwte[8][0]},    
                '4':{'1':gwte[9][0],'2':gwte[10][0],'3':gwte[11][0],'5':gwte[12][0],'7':gwte[13][0],'10':gwte[14][0]},'5':{'2':gwte[15][0],'4':gwte[16][0],'10':gwte[17][0],'11':gwte[18][0]}, '6':{'3':gwte[19][0],'7':gwte[20][0],'8':gwte[21][0]},
                '7':{'4':gwte[22][0],'6':gwte[23][0],'9':gwte[24][0]}, '8':{'6':gwte[25][0],'9':gwte[26][0]}, '9':{'7':gwte[27][0],'8':gwte[28][0],'10':gwte[29][0]},
                '10':{'4':gwte[30][0],'5':gwte[31][0],'9':gwte[32][0],'11':gwte[33][0],'12':gwte[34][0]}, '11':{'5':gwte[35][0],'10':gwte[36][0],'12':gwte[37][0],'14':gwte[38][0]}, '12':{'10':gwte[39][0],'11':gwte[40][0],'13':gwte[41][0]},
                '13':{'12':gwte[42][0],'14':gwte[43][0]}, '14':{'11':gwte[44][0],'13':gwte[45][0]}
                }  , nodes[i], nodes[j])
                if i == j:
                    continue  # don't include lightpaths of length 0
                else:
                    dis.append(d)
                    path.append(p)
    elif graphA == graphAL:
        for i in range(numnodes):    
            for j in range(numnodes): 
                d, p = dijkstra({'1':{'4':gwte[0][0],'5':gwte[1][0]},'2':{'3':gwte[2][0],'7':gwte[3][0]},'3':{'2':gwte[4][0],'8':gwte[5][0]},    
                '4':{'1':gwte[6][0],'5':gwte[7][0],'9':gwte[8][0]},'5':{'1':gwte[9][0],'4':gwte[10][0],'6':gwte[11][0]}, '6':{'5':gwte[12][0],'7':gwte[13][0],'11':gwte[14][0]},
                '7':{'2':gwte[15][0],'6':gwte[16][0],'10':gwte[17][0]}, '8':{'3':gwte[18][0],'10':gwte[19][0]}, '9':{'4':gwte[20][0],'11':gwte[21][0]},
                '10':{'7':gwte[22][0],'8':gwte[23][0],'11':gwte[24][0]}, '11':{'6':gwte[25][0],'9':gwte[26][0],'10':gwte[27][0]}
                }  , nodes[i], nodes[j])
                if i == j:
                    continue  # don't include lightpaths of length 0
                else:
                    dis.append(d)
                    path.append(p)
    pathdists = []
    links = []                                                
    for i in range(np.size(path)):
        pathdists.append(getlinklen(path[i],graphnormA,edges)[0])
        links.append(getlinklen(path[i],graph,edges)[1])
    
    estlam = np.zeros([numedges,numlam]) # 0 for empty, 1 for occupied
    reqlams = 0
    conten = 0
    failures = 0
    ct128 = 0
    ct64 = 0
    ct16 =0 
    ct4 = 0
    ct2 = 0
    numreq = np.size(Rsource)
    randdist = []
    conf = []
    for i in range(numreq):
        # update for online learning 
        #  choose random source and destination nodes 
        #Rsource, Rdest = requestgen(graph)
        # find corresponding path index
        def srcdestcheck(path,src,dest):
            if path[0] == src and path[-1] == dest:
                return True  
        randpathind = [j for j in range(np.size(path)) if  srcdestcheck(path[j], Rsource[i], Rdest[i])][0]
        #print("selected request index: " + str(randpathind))
        randedges = links[randpathind]  # selected edges for request 
        randdist.append(sum(pathdists[randpathind]))
        lamconten = False
        testlamslot = [np.where(estlam[randedges[k]]==0) for k in range(np.size(randedges))]
        for g in range(np.size(randedges)):
            if np.size(testlamslot[g]) == 0:
                #print("all wavelength slots are full")
                lamconten = True
                continue
        if lamconten:
            conten = conten + 1
            continue
        lamslot = [np.where(estlam[randedges[k]]==0)[0][0] for k in range(np.size(links[randpathind]))] # first available wavelength slot for this edge
        # need to check SNR for all the edges in the path
        edgesuc = 0
        edgesuc2 = 0
        FT = np.zeros(np.size(linkSNR[randedges],0))
        for j in range(np.size(linkSNR[randedges],0)): # for each edge in the path
            #if linkSNR[randedges][j][prmnopt[randedges[j]]] > FT:
        
            if prmn[randedges][j][prmnopt[randedges[j]]] > FT128 and (prmn[randedges][j][prmnopt[randedges[j]]] - FT128)/gsige[randedges[j]] > numsig:
                conf.append((prmn[randedges][j][prmnopt[randedges[j]]] - FT128)/gsige[randedges[j]])
                FT[j] = FT128
                ct128 = ct128 + 1
                edgesuc = edgesuc + 1
            elif prmn[randedges][j][prmnopt[randedges[j]]] > FT64 and (prmn[randedges][j][prmnopt[randedges[j]]] - FT64)/gsige[randedges[j]] > numsig:
                conf.append((prmn[randedges][j][prmnopt[randedges[j]]] - FT64)/gsige[randedges[j]])
                FT[j] = FT64
                ct64 = ct64 + 1
                edgesuc = edgesuc + 1
            elif prmn[randedges][j][prmnopt[randedges[j]]] > FT16 and (prmn[randedges][j][prmnopt[randedges[j]]] - FT16)/gsige[randedges[j]] > numsig:
                conf.append((prmn[randedges][j][prmnopt[randedges[j]]] - FT16)/gsige[randedges[j]])
                FT[j] = FT16
                ct16 = ct16 + 1
                edgesuc = edgesuc + 1
            elif prmn[randedges][j][prmnopt[randedges[j]]] > FT4 and (prmn[randedges][j][prmnopt[randedges[j]]] - FT4)/gsige[randedges[j]] > numsig:
                conf.append((prmn[randedges][j][prmnopt[randedges[j]]] - FT4)/gsige[randedges[j]])
                FT[j] = FT4
                ct4 = ct4 + 1
                edgesuc = edgesuc + 1
            elif prmn[randedges][j][prmnopt[randedges[j]]] > FT2 and (prmn[randedges][j][prmnopt[randedges[j]]] - FT2)/gsige[randedges[j]] > numsig:
                conf.append((prmn[randedges][j][prmnopt[randedges[j]]] - FT2)/gsige[randedges[j]])
                FT[j] = FT2
                ct2 = ct2 + 1
                edgesuc = edgesuc + 1
            else:
                #print("request " + str(i) + " denied -- insufficient reach on edge " + str(randedges[j]))
                break   
       
        if edgesuc == np.size(linkSNR[randedges],0):
            # generate new SNR value here
            for w in range(np.size(randedges)):
                estSNR = SNRnew(edgelens[randedges[w]], linkpert[randedges[w]], linkPch[randedges[w]], Lspans, np.count_nonzero(estlam[randedges[w]])+1 )
                #estSNR = SNRnew(edgelens[randedges[w]], linkpert[randedges[w]], linkPch[0][randedges[w]])
                if estSNR > FT[w]:
                    # link successfully established
                    edgesuc2 = edgesuc2 + 1
            if edgesuc2 == np.size(randedges):
                # path successfully established
                reqlams = reqlams + 1
                for l in range(len(randedges)):
                    estlam[randedges[l]][lamslot[l]] = 1
            else: 
                # link not established
                failures = failures + 1
    ava = (reqlams/numreq)*100 
    tottime = ((sum(randdist)*1e3*1.468)/299792458)[0]
    if showres:
        print("Variance-aided availability = " + str(ava) + "%") 
        print("Variance-aided total traversal time = " + str('%.2f' % tottime) + "s")
    return ava, estlam, reqlams, tottime,conten, conf, ct128, ct64, ct16, ct4,ct2, failures

# %%
# ========== this loop resets the network loading after numreqs, numtests times  ===========
def testrout(graph, graphvar, edges, numtests,showres,numsig, numreq):

    avaf = np.empty([numtests,1])
    tottimef = np.empty([numtests,1])
    contenf = np.empty([numtests,1])
    ct128f = np.empty([numtests,1])
    ct64f = np.empty([numtests,1])
    ct16f = np.empty([numtests,1])
    ct4f = np.empty([numtests,1])
    ct2f = np.empty([numtests,1])
    failf = np.empty([numtests,1])
    noreachf = np.empty([numtests,1])
    ava = np.empty([numtests,1])
    tottime = np.empty([numtests,1])
    conten = np.empty([numtests,1])
    ct128 = np.empty([numtests,1])
    ct64 = np.empty([numtests,1])
    ct16 = np.empty([numtests,1])
    ct4 = np.empty([numtests,1])
    ct2 = np.empty([numtests,1])
    fail = np.empty([numtests,1])
    avav = np.empty([numtests,1])
    tottimev = np.empty([numtests,1])
    contenv = np.empty([numtests,1])
    ct128v = np.empty([numtests,1])
    ct64v = np.empty([numtests,1])
    ct16v = np.empty([numtests,1])
    ct4v = np.empty([numtests,1])
    ct2v = np.empty([numtests,1])
    failv = np.empty([numtests,1])
    avavp = np.empty([numtests,1])
    tottimevp = np.empty([numtests,1])
    contenvp = np.empty([numtests,1])
    ct128vp = np.empty([numtests,1])
    ct64vp = np.empty([numtests,1])
    ct16vp = np.empty([numtests,1])
    ct4vp = np.empty([numtests,1])
    ct2vp = np.empty([numtests,1])
    failvp = np.empty([numtests,1])


    
    for i in range(numtests):
        # pre-determine 100 random requests 
        
        rsrct = []
        rdest = []
        for _ in range(numreq):
            rsct, rdst = requestgen(graph)
            rsrct.append(rsct)
            rdest.append(rdst)
        #ava[i], _, _, tottime[i],conten[i],ct128[i],ct64[i],ct16[i], ct4[i],ct2[i], fail[i]  = basicrta(graph,edges,rsrct,rdest,showres,nodesA,numedgesA,edgelensA,LspansA)
        #avav[i], _, _, tottimev[i], contenv[i],ct128v[i],ct64v[i],ct16v[i], ct4v[i],ct2v[i], failv[i]   = varrta(graphvar,edges,rsrct,rdest,showres,nodesA,numedgesA,edgelensA,LspansA)
        avavp[i], _, _, tottimevp[i], contenvp[i], conf , ct128vp[i], ct64vp[i],ct16vp[i], ct4vp[i],ct2vp[i], failvp[i]   = varrtap(graphvared,edges,rsrct,rdest,showres,numsig,nodesA,numedgesA,edgelensA,LspansA)
        avaf[i], _, _, tottimef[i], contenf[i], ct128f[i], ct64f[i],ct16f[i], ct4f[i],ct2f[i], failf[i], noreachf[i]   = fmrta(graph,edges,rsrct,rdest,showres,margin,nodesA,numedgesA,edgelensA,fmSNR,LspansA)
    
    avaave = np.mean(ava)
    ttave = np.mean(tottime)
    wavconave = np.mean(conten/numreq)*100 # express as a %
    failave = np.mean(fail/numreq)*100 # express as a %
    avaavev = np.mean(avav)
    ttavev = np.mean(tottimev)
    wavconavev = np.mean(contenv/numreq)*100 # express as a %
    failavev = np.mean(failv/numreq)*100 # express as a %
    avaavevp = np.mean(avavp)
    ttavevp = np.mean(tottimevp)
    wavconavevp = np.mean(contenvp/numreq)*100 # express as a %
    failavevp = np.mean(failvp/numreq)*100 # express as a %
    avaavef = np.mean(avaf)
    ttavef = np.mean(tottimef)
    wavconavef = np.mean(contenf/numreq)*100 # express as a %
    failavef = np.mean(failf/numreq)*100 # express as a %
    norchavef = np.mean(noreachf/numreq)*100
    
    ct128ave = np.mean(ct128)
    ct64ave = np.mean(ct64)
    ct16ave = np.mean(ct16)
    ct4ave = np.mean(ct4)
    ct2ave = np.mean(ct2)
    ct128avev = np.mean(ct128v)
    ct64avev = np.mean(ct64v)
    ct16avev = np.mean(ct16v)
    ct4avev = np.mean(ct4v)
    ct2avev = np.mean(ct2v)
    ct128avevp = np.mean(ct128vp)
    ct64avevp = np.mean(ct64vp)
    ct16avevp = np.mean(ct16vp)
    ct4avevp = np.mean(ct4vp)
    ct2avevp = np.mean(ct2vp)
    ct128avef = np.mean(ct128f)
    ct64avef = np.mean(ct64f)
    ct16avef = np.mean(ct16f)
    ct4avef = np.mean(ct4f)
    ct2avef = np.mean(ct2f)
    
    thrpt = 2*(ct128ave*7 + ct64ave*6 + ct16ave*4 + ct4ave*2 + ct2ave)/(ct128ave + ct64ave + ct16ave + ct4ave + ct2ave)
    thrptv = 2*(ct128avev*7 + ct64avev*6 + ct16avev*4 + ct4avev*2 + ct2avev)/(ct128avev + ct64avev + ct16avev + ct4avev + ct2avev)
    thrptvp = 2*(ct128avevp*7 + ct64avevp*6 + ct16avevp*4 + ct4avevp*2 + ct2avevp)/(ct128avevp + ct64avevp + ct16avevp + ct4avevp + ct2avevp)
    thrptf = 2*(ct128avef*7 + ct64avef*6 + ct16avef*4 + ct4avef*2 + ct2avef)/(ct128avef + ct64avef + ct16avef + ct4avef + + ct2avef)
        
    return avaave, wavconave, failave ,ttave, thrpt,avaavev, wavconavev, failavev ,ttavev, thrptv, avaavevp, wavconavevp, failavevp ,ttavevp, thrptvp, avaavef, wavconavef, failavef ,ttavef, thrptf, norchavef

reqvar = True
if reqvar:
    numreq = np.linspace(150,500,21,dtype=int)
    numsig = 4.5
    nrs = np.size(numreq)
    avaave = np.empty([nrs,1])
    wavconave = np.empty([nrs,1])
    failave = np.empty([nrs,1])
    ttave = np.empty([nrs,1])
    thrpt = np.empty([nrs,1]) 
    avaavev = np.empty([nrs,1])
    wavconavev = np.empty([nrs,1])
    failavev = np.empty([nrs,1])
    ttavev = np.empty([nrs,1])
    thrptv = np.empty([nrs,1]) 
    avaavevp = np.empty([nrs,1])
    wavconavevp = np.empty([nrs,1])
    failavevp = np.empty([nrs,1])
    ttavevp = np.empty([nrs,1])
    thrptvp = np.empty([nrs,1]) 
    avaavef = np.empty([nrs,1])
    wavconavef = np.empty([nrs,1])
    failavef = np.empty([nrs,1])
    ttavef = np.empty([nrs,1])
    thrptf = np.empty([nrs,1])
    norchavef = np.empty([nrs,1])
    start_time = time.time()
    for i in range(nrs):     
        avaave[i], wavconave[i], failave[i] ,ttave[i], thrpt[i], avaavev[i], wavconavev[i], failavev[i] ,ttavev[i], thrptv[i], avaavevp[i], wavconavevp[i], failavevp[i],ttavevp[i], thrptvp[i], avaavef[i], wavconavef[i], failavef[i] ,ttavef[i], thrptf[i], norchavef[i] = testrout(graphA, graphvar, edgesA, 20,False,numsig,numreq[i])
    end_time = time.time()
    duration = time.time() - start_time
else:
    numreq = 250
    numsig = np.linspace(0.5,6,21)
    nrs = np.size(numsig)
    avaave = np.empty([nrs,1])
    wavconave = np.empty([nrs,1])
    failave = np.empty([nrs,1])
    ttave = np.empty([nrs,1])
    thrpt = np.empty([nrs,1]) 
    avaavev = np.empty([nrs,1])
    wavconavev = np.empty([nrs,1])
    failavev = np.empty([nrs,1])
    ttavev = np.empty([nrs,1])
    thrptv = np.empty([nrs,1]) 
    avaavevp = np.empty([nrs,1])
    wavconavevp = np.empty([nrs,1])
    failavevp = np.empty([nrs,1])
    ttavevp = np.empty([nrs,1])
    thrptvp = np.empty([nrs,1]) 
    avaavef = np.empty([nrs,1])
    wavconavef = np.empty([nrs,1])
    failavef = np.empty([nrs,1])
    ttavef = np.empty([nrs,1])
    thrptf = np.empty([nrs,1])
    norchavef = np.empty([nrs,1])
    start_time = time.time()
    for i in range(nrs):
        avaave[i], wavconave[i], failave[i] ,ttave[i], thrpt[i], avaavev[i], wavconavev[i], failavev[i] ,ttavev[i], thrptv[i], avaavevp[i], wavconavevp[i], failavevp[i],ttavevp[i], thrptvp[i], avaavef[i], wavconavef[i], failavef[i] ,ttavef[i], thrptf[i], norchavef[i] = testrout(graphA, graphvar, edgesA, 10,False,numsig[i],numreq)
    end_time = time.time()
    duration = time.time() - start_time

print("Routing calculation duration: " + str(duration))

# %% plotting
font = { 'family' : 'sans-serif',
        'weight' : 'normal',
        'size'   : 15}
matplotlib.rc('font', **font)

if reqvar:
    plt.plot(numreq, avaavevp, label="GP")
    plt.plot(numreq, avaavef, label="FM")
    plt.legend()
    plt.xlabel("No. of requests")
    plt.ylabel("Availability (%)")
    plt.savefig('Avavsnreq.pdf', dpi=200,bbox_inches='tight')
    plt.show() 
    
    plt.plot(numreq, wavconavevp, label="GP")
    plt.plot(numreq, wavconavef, label="FM")
    plt.legend()
    plt.xlabel("No. of requests")
    plt.ylabel("Wavelength contention (%)")
    plt.savefig('Wlcvsnreq.pdf', dpi=200,bbox_inches='tight')
    plt.show() 
    
    plt.plot(numreq, failavevp, label="GP")
    plt.plot(numreq, failavef, label="FM")
    plt.legend()
    plt.xlabel("No. of requests")
    plt.ylabel("Failure post-reach est. (%)")
    plt.savefig('failvsnreq.pdf', dpi=200,bbox_inches='tight')
    plt.show() 
    
    plt.plot(numreq, thrptvp, label="GP")
    plt.plot(numreq, thrptf, label="FM")
    plt.legend()
    plt.xlabel("No. of requests")
    plt.ylabel("Spectral Efficiency (bits/sym)")
    plt.savefig('Thrptvsnreq.pdf', dpi=200,bbox_inches='tight')
    plt.show() 
    
    Rs = 32
    totthrptvp = thrptvp*avaavevp*Rs*1e-2
    totthrptf = thrptf*avaavef*Rs*1e-2
    
    plt.plot(numreq, totthrptvp, label="GP")
    plt.plot(numreq, totthrptf, label="FM")
    plt.legend()
    plt.xlabel("No. of requests")
    plt.ylabel("Total throughput (Gb/s)")
    plt.savefig('Totalthrptvsnreq.pdf', dpi=200,bbox_inches='tight')
    plt.show() 
    
    
    
else: 
    plt.plot(numsig, avaavevp, label="GP")
    plt.plot(numsig, avaavef, label="FM")
    plt.legend()
    plt.xlabel("$\sigma$")
    plt.ylabel("Availability (%)")
    plt.savefig('Avavsnsig.pdf', dpi=200,bbox_inches='tight')
    plt.show() 
    
    plt.plot(numsig, wavconavevp, label="GP")
    plt.plot(numsig, wavconavef, label="FM")
    plt.legend()
    plt.xlabel("$\sigma$")
    plt.ylabel("Wavelength contention (%)")
    plt.savefig('Wlcvsnsig.pdf', dpi=200,bbox_inches='tight')
    plt.show() 
    
    plt.plot(numsig, failavevp, label="GP")
    plt.plot(numsig, failavef, label="FM")
    plt.legend()   
    plt.xlabel("$\sigma$")
    plt.ylabel("Failure post-reach est. (%)")
    plt.savefig('failvsnsig.pdf', dpi=200,bbox_inches='tight')
    plt.show() 
    
    plt.plot(numsig, thrptvp, label="GP")
    plt.plot(numsig, thrptf, label="FM")
    plt.legend()    
    plt.xlabel("$\sigma$")
    plt.ylabel("Spectral Efficiency (bits/sym)")
    plt.savefig('Thrptvsnsig.pdf', dpi=200,bbox_inches='tight')
    plt.show() 
    
    Rs = 32
    totthrptvp = thrptvp*avaavevp*Rs*1e-2
    totthrptf = thrptf*avaavef*Rs*1e-2
    
    plt.plot(numsig, totthrptvp, label="GP")
    plt.plot(numsig, totthrptf, label="FM")
    plt.legend()
    plt.xlabel("$\sigma$")
    plt.ylabel("Total throughput (Gb/s)")
    plt.savefig('Totalthrptvsnsig.pdf', dpi=200,bbox_inches='tight')
    plt.show() 
    
# =============================================================================
# print("----------------------------------------------------------")
# print("Fixed margin average availability " + str(avaavef) + "%")
# print("Fixed margin wavelength contention est "  + str('%.2f' % wavconavef) + "%")
# print("Fixed margin failure post-reach est "  + str('%.2f' % failavef)+ "%")
# print("Fixed margin reach assignment failure "  + str('%.2f' % norchavef)+ "%")
# print("Fixed margin average latency " + str('%.4f' % ttavef) + "s")
# print("Fixed margin throughput est "  + str('%.4f' % thrptf) + " bits/sym")
# print("----------------------------------------------------------")
# print("Database average availability " + str(avaave) + "%")
# print("Database wavelength contention est "  + str('%.2f' % wavconave) + "%")
# print("Database failure post-reach est "  + str('%.2f' % failave)+ "%")
# print("Database average latency " + str('%.4f' % ttave) + "s")
# print("Database throughput est "  + str('%.4f' % thrpt) + " bits/sym")
# print("----------------------------------------------------------")
# print("Variance-aided average availability " + str(avaavev) + "%")
# print("Variance-aided wavelength contention est "  + str('%.2f' % wavconavev) + "%")
# print("Variance-aided failure post-reach est "  + str('%.2f' % failavev) + "%")
# print("Variance-aided average latency " + str('%.4f' % ttavev) + "s")
# print("Variance-aided throughput est " + str('%.4f' % thrptv)+ " bits/sym")
# print("----------------------------------------------------------")
# print("Variance-aided power-adjusted average availability " + str(avaavevp) + "%")
# print("Variance-aided power-adjusted wavelength contention est "  + str('%.2f' % wavconavevp) + "%")
# print("Variance-aided power-adjusted failure post-reach est "  + str('%.2f' % failavevp) + "%")
# print("Variance-aided power-adjusted average latency " + str('%.4f' % ttavevp) + "s")
# print("Variance-aided power-adjusted throughput est " + str('%.2f' % thrptvp)+ " bits/sym")
# print("----------------------------------------------------------")
# =============================================================================

# %% ================================ Mutual information estimation ===========================================
  
# import constellation shapes from MATLAB-generated csv files 
if constellationimport:  
    Qam4r = np.genfromtxt(open("qam4r.csv", "r"), delimiter=",", dtype =float)
    Qam4i = np.genfromtxt(open("qam4i.csv", "r"), delimiter=",", dtype =float)
    Qam16r = np.genfromtxt(open("qam16r.csv", "r"), delimiter=",", dtype =float)
    Qam16i = np.genfromtxt(open("qam16i.csv", "r"), delimiter=",", dtype =float)
    Qam32r = np.genfromtxt(open("qam32r.csv", "r"), delimiter=",", dtype =float)
    Qam32i = np.genfromtxt(open("qam32i.csv", "r"), delimiter=",", dtype =float)
    Qam64r = np.genfromtxt(open("qam64r.csv", "r"), delimiter=",", dtype =float)
    Qam64i = np.genfromtxt(open("qam64i.csv", "r"), delimiter=",", dtype =float)
    Qam128r = np.genfromtxt(open("qam128r.csv", "r"), delimiter=",", dtype =float)
    Qam128i = np.genfromtxt(open("qam128i.csv", "r"), delimiter=",", dtype =float)
    
    Qam4 = Qam4r + 1j*Qam4i
    Qam16 = Qam16r + 1j*Qam16i
    Qam32 = Qam32r + 1j*Qam32i
    Qam64 = Qam64r + 1j*Qam64i
    Qam128 = Qam128r + 1j*Qam128i

# %% ================================ Estimate MI ================================ 
if MIstuff:
    # set modulation format order and number of terms used in Gauss-Hermite quadrature
    M = 4
    L = 10
    
    def MIGHquad(SNR):
        if M == 4:
            Ps = np.mean(np.abs(Qam4**2))
            X = Qam4
        elif M == 16:
            Ps = np.mean(np.abs(Qam16**2))
            X = Qam16
        elif M == 32:
            Ps = np.mean(np.abs(Qam32**2))
            X = Qam32
        elif M == 64:
            Ps = np.mean(np.abs(Qam64**2))
            X = Qam64
        elif M == 128:
            Ps = np.mean(np.abs(Qam128**2))
            X = Qam128
        else:
            print("unrecogised M")
        sigeff2 = Ps/(10**(SNR/10))
        Wgh = GHquad(L)[0]
        Rgh = GHquad(L)[1]
        sum_out = 0
        for ii in range(M):
            sum_in = 0
            for l1 in range(L):      
                sum_inn = 0
                for l2 in range(L):
                    sum_exp = 0
                    for jj in range(M):  
                        arg_exp = np.linalg.norm(X[ii]-X[jj])**2 + 2*(sigeff2**0.5)*np.real( (Rgh[l1]+1j*Rgh[l2])*(X[ii]-X[jj]));
                        sum_exp = np.exp(-arg_exp/sigeff2) + sum_exp
                    sum_inn = Wgh[l2]*np.log2(sum_exp) + sum_inn
                sum_in = Wgh[l1]*sum_inn + sum_in
            sum_out = sum_in + sum_out
        return np.log2(M)- (1/(M*np.pi))*sum_out 
    
    def findMI(SNR):
        with multiprocessing.Pool() as pool:
            Ixy = pool.map(MIGHquad, SNR) 
        return Ixy
    
    MIripple = findMI(SNRripple)
    
    # %%
    
    plt.plot(Pchripple, MIripple,'+')
    plt.show()
    # =============================================================================
    # start_time = time.time()
    # IxyNy = findMI(SNRanalyticalbase)
    # IxyRS = findMI(SNRanalyticalRSbase)
    # IxyRS2 = findMI(SNRanalyticalRS2base)
    # duration = time.time() - start_time
    # print("MI calculation duration: " + str(duration))
    # =============================================================================

# %% ================================== Reach calculation ==================================
if reachcalculation:
# find the BER from: On the Bit Error Probability of QAM Modulation - Michael P. Fitz 
    PchreachdBm = np.linspace(-5,5,numpoints)
    lossreach = NDFISlossoverallnzmean
    dispreach = NDFISdispnzmean
    # =============================================================================
    SNRNYr = GNmain(Lspans, Nspans, 157, 101, 201, lossreach,dispreach, PchreachdBm, NF, NLco,False,numpoints)[0]
    SNRRSr = GNmain(Lspans, Nspans, 157, 101, 201, lossreach, dispreach, PchreachdBm, NF, NLco,False,numpoints)[1]
    SNRRS2r = GNmain(Lspans, Nspans, 157, 101, 201, lossreach, dispreach, PchreachdBm, NF, NLco,False,numpoints)[2]
    # Ny = 0 for Nyquist, 1 for RS and 2 for RS2
    def reachcalc(Ny, P, M):
        FECthreshold = 2e-2
        BER = np.zeros(numpoints)
        Ns = 20 # start at 2 spans because of the denominator of (22) in Poggiolini's GN model paper - divide by ln(Ns) = 0 for Ns = 1
        while BER[0] < FECthreshold:               
            SNR = GNmain(Lspans, Ns, 157, 101, 201, alpha, Disp, P, NF, NLco,False,numpoints)[Ny]                
            if M == 4: 
                BER = 0.5*special.erfc(SNR**0.5)                    
            elif M == 16:
                BER = (3/8)*special.erfc(((2/5)*SNR)**0.5) + (1/4)*special.erfc(((18/5)*SNR)**0.5) - (1/8)*special.erfc((10*SNR)**0.5)                    
            elif M == 64:
                BER = (7/24)*special.erfc(((1/7)*SNR)**0.5) + (1/4)*special.erfc(((9/7)*SNR)**0.5) - (1/24)*special.erfc(((25/7)*SNR)**0.5) - (1/24)*special.erfc(((25/7)*SNR)**0.5) + (1/24)*special.erfc(((81/7)*SNR)**0.5) - (1/24)*special.erfc(((169/7)*SNR)**0.5)     
            else:
                print("unrecognised modulation format")    
            Ns = Ns + 1
        return Ns
    
    test = reachcalc(0, 0, 64)
       
# %% ================================== plotting =================================
#GNPysnr = np.genfromtxt(open("SNRGNPy.csv", "r"), delimiter=",", dtype =float)
#GNPyosnr = np.genfromtxt(open("OSNRGNPy.csv", "r"), delimiter=",", dtype =float)








    
